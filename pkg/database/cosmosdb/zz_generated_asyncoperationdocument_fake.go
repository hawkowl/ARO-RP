// Code generated by github.com/jim-minter/go-cosmosdb, DO NOT EDIT.

package cosmosdb

import (
	"context"
	"fmt"
	"net/http"
	"reflect"
	"sync"

	"github.com/ugorji/go/codec"

	pkg "github.com/Azure/ARO-RP/pkg/api"
)

type fakeAsyncOperationDocumentTrigger func(context.Context, *pkg.AsyncOperationDocument) error
type fakeAsyncOperationDocumentQuery func(AsyncOperationDocumentClient, *Query, *Options) AsyncOperationDocumentRawIterator

var _ AsyncOperationDocumentClient = &FakeAsyncOperationDocumentClient{}

func NewFakeAsyncOperationDocumentClient(h *codec.JsonHandle) *FakeAsyncOperationDocumentClient {
	return &FakeAsyncOperationDocumentClient{
		docs:              make(map[string][]byte),
		triggers:          make(map[string]fakeAsyncOperationDocumentTrigger),
		queries:           make(map[string]fakeAsyncOperationDocumentQuery),
		jsonHandle:        h,
		lock:              &sync.RWMutex{},
		sorter:            func(in []*pkg.AsyncOperationDocument) {},
		checkDocsConflict: func(*pkg.AsyncOperationDocument, *pkg.AsyncOperationDocument) bool { return false },
	}
}

type FakeAsyncOperationDocumentClient struct {
	docs       map[string][]byte
	jsonHandle *codec.JsonHandle
	lock       *sync.RWMutex
	triggers   map[string]fakeAsyncOperationDocumentTrigger
	queries    map[string]fakeAsyncOperationDocumentQuery
	sorter     func([]*pkg.AsyncOperationDocument)

	// returns true if documents conflict
	checkDocsConflict func(*pkg.AsyncOperationDocument, *pkg.AsyncOperationDocument) bool

	// unavailable, if not nil, is an error to throw when attempting to
	// communicate with this Client
	unavailable error
}

func (c *FakeAsyncOperationDocumentClient) decodeAsyncOperationDocument(s []byte) (*pkg.AsyncOperationDocument, error) {
	res := &pkg.AsyncOperationDocument{}
	err := codec.NewDecoderBytes(s, c.jsonHandle).Decode(&res)
	return res, err
}

func (c *FakeAsyncOperationDocumentClient) encodeAsyncOperationDocument(doc *pkg.AsyncOperationDocument) ([]byte, error) {
	res := make([]byte, 0)
	err := codec.NewEncoderBytes(&res, c.jsonHandle).Encode(doc)
	if err != nil {
		return nil, err
	}
	return res, err
}

func (c *FakeAsyncOperationDocumentClient) MakeUnavailable(err error) {
	c.lock.Lock()
	defer c.lock.Unlock()
	c.unavailable = err
}

func (c *FakeAsyncOperationDocumentClient) UseSorter(sorter func([]*pkg.AsyncOperationDocument)) {
	c.sorter = sorter
}

func (c *FakeAsyncOperationDocumentClient) UseDocumentConflictChecker(checker func(*pkg.AsyncOperationDocument, *pkg.AsyncOperationDocument) bool) {
	c.checkDocsConflict = checker
}

func (c *FakeAsyncOperationDocumentClient) InjectTrigger(trigger string, impl fakeAsyncOperationDocumentTrigger) {
	c.triggers[trigger] = impl
}

func (c *FakeAsyncOperationDocumentClient) InjectQuery(query string, impl fakeAsyncOperationDocumentQuery) {
	c.queries[query] = impl
}

func (c *FakeAsyncOperationDocumentClient) encodeAndCopy(doc *pkg.AsyncOperationDocument) (*pkg.AsyncOperationDocument, []byte, error) {
	encoded, err := c.encodeAsyncOperationDocument(doc)
	if err != nil {
		return nil, nil, err
	}
	res, err := c.decodeAsyncOperationDocument(encoded)
	if err != nil {
		return nil, nil, err
	}
	return res, encoded, err
}

func (c *FakeAsyncOperationDocumentClient) apply(ctx context.Context, partitionkey string, doc *pkg.AsyncOperationDocument, options *Options, isNew bool) (*pkg.AsyncOperationDocument, error) {
	var docExists bool
	c.lock.Lock()
	defer c.lock.Unlock()

	if options != nil {
		err := c.processPreTriggers(ctx, doc, options)
		if err != nil {
			return nil, err
		}
	}

	res, enc, err := c.encodeAndCopy(doc)
	if err != nil {
		return nil, err
	}

	for _, ext := range c.docs {
		dec, err := c.decodeAsyncOperationDocument(ext)
		if err != nil {
			return nil, err
		}

		if dec.ID == res.ID {
			// If the document exists in the database, we want to error out in a
			// create but mark the document as extant so it can be replaced if
			// it is an update
			if isNew {
				return nil, &Error{
					StatusCode: http.StatusConflict,
					Message:    "Entity with the specified id already exists in the system",
				}
			} else {
				docExists = true
			}
		} else {
			if c.checkDocsConflict(dec, res) {
				return nil, &Error{
					StatusCode: http.StatusConflict,
					Message:    "Entity with the specified id already exists in the system",
				}
			}
		}
	}

	if !isNew && !docExists {
		return nil, &Error{StatusCode: http.StatusNotFound}
	}

	c.docs[doc.ID] = enc
	return res, nil
}

func (c *FakeAsyncOperationDocumentClient) Create(ctx context.Context, partitionkey string, doc *pkg.AsyncOperationDocument, options *Options) (*pkg.AsyncOperationDocument, error) {
	if c.unavailable != nil {
		return nil, c.unavailable
	}
	return c.apply(ctx, partitionkey, doc, options, true)
}

func (c *FakeAsyncOperationDocumentClient) Replace(ctx context.Context, partitionkey string, doc *pkg.AsyncOperationDocument, options *Options) (*pkg.AsyncOperationDocument, error) {
	if c.unavailable != nil {
		return nil, c.unavailable
	}
	return c.apply(ctx, partitionkey, doc, options, false)
}

func (c *FakeAsyncOperationDocumentClient) List(*Options) AsyncOperationDocumentIterator {
	if c.unavailable != nil {
		return NewFakeAsyncOperationDocumentClientErroringRawIterator(c.unavailable)
	}
	c.lock.RLock()
	defer c.lock.RUnlock()

	docs := make([]*pkg.AsyncOperationDocument, 0, len(c.docs))
	for _, d := range c.docs {
		r, err := c.decodeAsyncOperationDocument(d)
		if err != nil {
			return NewFakeAsyncOperationDocumentClientErroringRawIterator(err)
		}
		docs = append(docs, r)
	}
	c.sorter(docs)
	return NewFakeAsyncOperationDocumentClientRawIterator(docs, 0)
}

func (c *FakeAsyncOperationDocumentClient) ListAll(ctx context.Context, opts *Options) (*pkg.AsyncOperationDocuments, error) {
	if c.unavailable != nil {
		return nil, c.unavailable
	}
	iter := c.List(opts)
	asyncOperationDocuments, err := iter.Next(ctx, -1)
	if err != nil {
		return nil, err
	}
	return asyncOperationDocuments, nil
}

func (c *FakeAsyncOperationDocumentClient) Get(ctx context.Context, partitionkey string, documentId string, options *Options) (*pkg.AsyncOperationDocument, error) {
	if c.unavailable != nil {
		return nil, c.unavailable
	}
	c.lock.RLock()
	defer c.lock.RUnlock()

	out, ext := c.docs[documentId]
	if !ext {
		return nil, &Error{StatusCode: http.StatusNotFound}
	}
	return c.decodeAsyncOperationDocument(out)
}

func (c *FakeAsyncOperationDocumentClient) Delete(ctx context.Context, partitionKey string, doc *pkg.AsyncOperationDocument, options *Options) error {
	if c.unavailable != nil {
		return c.unavailable
	}
	c.lock.Lock()
	defer c.lock.Unlock()

	_, ext := c.docs[doc.ID]
	if !ext {
		return &Error{StatusCode: http.StatusNotFound}
	}

	delete(c.docs, doc.ID)
	return nil
}

func (c *FakeAsyncOperationDocumentClient) ChangeFeed(*Options) AsyncOperationDocumentIterator {
	if c.unavailable != nil {
		return NewFakeAsyncOperationDocumentClientErroringRawIterator(c.unavailable)
	}
	return NewFakeAsyncOperationDocumentClientErroringRawIterator(ErrNotImplemented)
}

func (c *FakeAsyncOperationDocumentClient) processPreTriggers(ctx context.Context, doc *pkg.AsyncOperationDocument, options *Options) error {
	for _, trigger := range options.PreTriggers {
		trig, ok := c.triggers[trigger]
		if ok {
			err := trig(ctx, doc)
			if err != nil {
				return err
			}
		} else {
			return ErrNotImplemented
		}
	}
	return nil
}

func (c *FakeAsyncOperationDocumentClient) Query(name string, query *Query, options *Options) AsyncOperationDocumentRawIterator {
	if c.unavailable != nil {
		return NewFakeAsyncOperationDocumentClientErroringRawIterator(c.unavailable)
	}
	c.lock.RLock()
	defer c.lock.RUnlock()

	quer, ok := c.queries[query.Query]
	if ok {
		return quer(c, query, options)
	} else {
		return NewFakeAsyncOperationDocumentClientErroringRawIterator(ErrNotImplemented)
	}
}

func (c *FakeAsyncOperationDocumentClient) QueryAll(ctx context.Context, partitionkey string, query *Query, options *Options) (*pkg.AsyncOperationDocuments, error) {
	iter := c.Query("", query, options)
	return iter.Next(ctx, -1)
}

// NewFakeAsyncOperationDocumentClientRawIterator creates a RawIterator that will produce only
// AsyncOperationDocuments from Next() and NextRaw().
func NewFakeAsyncOperationDocumentClientRawIterator(docs []*pkg.AsyncOperationDocument, continuation int) AsyncOperationDocumentRawIterator {
	return &fakeAsyncOperationDocumentClientRawIterator{docs: docs, continuation: continuation}
}

type fakeAsyncOperationDocumentClientRawIterator struct {
	docs         []*pkg.AsyncOperationDocument
	continuation int
	done         bool
}

func (i *fakeAsyncOperationDocumentClientRawIterator) Next(ctx context.Context, maxItemCount int) (out *pkg.AsyncOperationDocuments, err error) {
	err = i.NextRaw(ctx, maxItemCount, &out)
	return
}

func (i *fakeAsyncOperationDocumentClientRawIterator) NextRaw(ctx context.Context, maxItemCount int, out interface{}) error {
	if i.done {
		return nil
	}

	var docs []*pkg.AsyncOperationDocument
	if maxItemCount == -1 {
		docs = i.docs[i.continuation:]
		i.continuation = len(i.docs)
		i.done = true
	} else {
		max := i.continuation + maxItemCount
		if max > len(i.docs) {
			max = len(i.docs)
		}
		docs = i.docs[i.continuation:max]
		i.continuation += max
		i.done = i.Continuation() == ""
	}

	y := reflect.ValueOf(out)
	d := &pkg.AsyncOperationDocuments{}
	d.AsyncOperationDocuments = docs
	d.Count = len(d.AsyncOperationDocuments)
	y.Elem().Set(reflect.ValueOf(d))
	return nil
}

func (i *fakeAsyncOperationDocumentClientRawIterator) Continuation() string {
	if i.continuation >= len(i.docs) {
		return ""
	}
	return fmt.Sprintf("%d", i.continuation)
}

// fakeAsyncOperationDocumentErroringRawIterator is a RawIterator that will return an error on use.
func NewFakeAsyncOperationDocumentClientErroringRawIterator(err error) *fakeAsyncOperationDocumentErroringRawIterator {
	return &fakeAsyncOperationDocumentErroringRawIterator{err: err}
}

type fakeAsyncOperationDocumentErroringRawIterator struct {
	err error
}

func (i *fakeAsyncOperationDocumentErroringRawIterator) Next(ctx context.Context, maxItemCount int) (*pkg.AsyncOperationDocuments, error) {
	return nil, i.err
}

func (i *fakeAsyncOperationDocumentErroringRawIterator) NextRaw(context.Context, int, interface{}) error {
	return i.err
}

func (i *fakeAsyncOperationDocumentErroringRawIterator) Continuation() string {
	return ""
}
